l[[1]]
l[[1]]$freq
map(l,'freq')
map_df(l,'freq')
l[[1]]$spec
out <- map_df(l, 'spec')
out
l %>% mutate(mspec = mean(X2, X3, X5))
out %>% mutate(mspec = mean(X2, X3, X5))
out %>% mutate(mspec = mean(X2:X5))
out %>% mutate(mspec = mean())
map(tmp, 'spec')
map(l, 'spec')
simplify(map(l, 'spec'))
map(l, 'spec')
simplify2array(map(l, 'spec'))
arr <- simplify2array(map(tmp, 'spec'))
tmp=l
arr <- simplify2array(map(tmp, 'spec'))
ff <- apply(arr, 2, mean)
ff
ff <- apply(arr, 1, mean)
ff
pwr <- apply(arr, 1, mean)
pow2db
pow2db(pwr)
welchpsd <- function(eegin, lf1, hf1, srate){
tmp <- apply(eegin, 1, function(x) pwelch(x, window = hanning(dim(eegin)[2]), fs = srate))
arr <- simplify2array(map(tmp, 'spec'))
pwr <- apply(arr, 1, mean)
}
seg  <- segmentation(onsets$relax, chanIndex, eeg)
eegm <- lapply(seg, demean)
l = welchpsd(eegm[[1]], lf1 = 2, hf1 = 10, srate = 250)
l
lapply(eegm, function(x) welchpsd(x, srate = 250))
welchpsd <- function(eegin, srate){
tmp <- apply(eegin, 1, function(x) pwelch(x, window = hanning(dim(eegin)[2]), fs = srate))
arr <- simplify2array(map(tmp, 'spec'))
pwr <- apply(arr, 1, mean)
}
seg  <- segmentation(onsets$relax, chanIndex, eeg)
eegm <- lapply(seg, demean)
lapply(eegm, function(x) welchpsd(x, srate = 250))
eegf <- lapply(eegm, function(x) welchpsd(x, srate = 250))
eegf
simlify2array(eegf)
simplify2array(eegf)
eegfa <- simplify2array(eegf)
dim(eegfa
)
powerEstimate <- simplify2array(eegf)
freqScale <- pwelch(eegm[[1]],
window = hanning(dim(eegm)[2]),
fs = srate)$freq
dim(eegm)[2]
freqScale <- pwelch(eegm[[1]],
window = hanning(dim(eegm[[1]])[2]),
fs = srate)$freq
eegm[[1]]
eegm[[1]][1,]
freqScale <- pwelch(eegm[[1]][1,],
window = hanning(dim(eegm[[1]])[2]),
fs = srate)$freq
freqScale
?near
freqScale > lf1
freqScale > lf1 & freqScale < hf1
which(freqScale > lf1 & freqScale < hf1)
freq1indices <- which(freqScale > lf1 & freqScale < hf1)
freq2indices <- which(freqScale > lf2 & freqScale < hf2)
freqScale[freq1indices]
powerEstimate
apply(powerEstimate, 1, mean)
plot(freqScale, apply(powerEstimate, 1, mean))
plot(freqScale, apply(powerEstimate, 1, mean), type='l')
near(freqScale, 4)
near(freqScale > 4)
(freqScale > 4)
which(freqScale > 4)
min(which(freqScale > 4))
min(which(freqScale > 4))-1
dim(powerEstimate)
mean(powerEstimate[freq1indices,])
)
apply(powerEstimate[freq1indices,], 1, mean)
apply(powerEstimate[freq1indices,], 2, mean)
plot(freqScale, f1pow, type='l', col = 'blue')
f1pow <- apply(powerEstimate[freq1indices,], 2, mean)
f2pow <- apply(powerEstimate[freq2indices,], 2, mean)
plot(freqScale, f1pow, type='l', col = 'blue')
f1pow
plot(f1pow, type='l', col = 'blue')
plot(f1pow / f2pow, type='l', col = 'blue')
seg  <- segmentation(onsets$relax, chanIndex, eeg)
eegm <- lapply(seg, demean)
eegf <- lapply(eegm, function(x) welchpsd(x, srate = 250))
powerEstimateRelax <- simplify2array(eegf)
seg  <- segmentation(onsets$concentrate, chanIndex, eeg)
eegm <- lapply(seg, demean)
eegf <- lapply(eegm, function(x) welchpsd(x, srate = 250))
powerEstimateConcentrate <- simplify2array(eegf)
freqScale <- pwelch(eegm[[1]][1,],
window = hanning(dim(eegm[[1]])[2]),
fs = srate)$freq
freq1indices <- which(freqScale > lf1 & freqScale < hf1)
freq2indices <- which(freqScale > lf2 & freqScale < hf2)
plot(freqScale, apply(powerEstimateRelax, 1, mean), type='l')
line(freqScale, apply(powerEstimateConcentrate, 1, mean), type='l')
line(freqScale, apply(powerEstimateConcentrate, 1, mean), type='l')
apply(powerEstimateConcentrate, 1, mean)
line(freqScale, apply(powerEstimateConcentrate, 1, mean), type='l')
lines(freqScale, apply(powerEstimateConcentrate, 1, mean), type='l')
plot(freqScale, apply(powerEstimateRelax, 1, mean),
type='l', col = 'blue')
lines(freqScale, apply(powerEstimateConcentrate, 1, mean),
type='l', col = 'red')
f1pow <- apply(powerEstimateRelax[freq1indices,], 2, mean)
f2pow <- apply(powerEstimateRelax[freq2indices,], 2, mean)
plot(f1pow / f2pow, type='l', col = 'blue')
welchpsd(rnorm(1,pollnum), srate = 250)
welchpsd(rnorm(pollnum), srate = 250)
rnorm(pollnum)
welchpsd(rnorm(pollnum),window = hanning(pollnum) srate = 250)
welchpsd(rnorm(pollnum),window = hanning(pollnum), srate = 250)$freq
welchpsd
pwelch(rnorm(pollnum),window = hanning(pollnum), srate = 250)$freq
pwelch(rnorm(pollnum),window = hanning(pollnum), fs = 250)$freq
freqScale <- pwelch(rnorm(pollnum),
window = hanning(pollnum),
fs = 250)$freq
testdat = runif(20)
testdat+
testdat
heat.colors(10)
visualFeedback <- function(colr){
plot(c(100, 200), c(100, 200),
type= "n", xlab = "", ylab = "", axes = FALSE)
rect(120, 140, 180, 160, border = colr, col = colr)
rect(140, 120, 160, 180, border = colr, col = colr)}
runif
testdat
round(testdat*100)
x11()
testdat = round(runif(20)*100) # 20 random integers from 0 - 100
hcol <- heat.colors(100) # from light yellow to red
visualFeedback <- function(colr){
plot(c(100, 200), c(100, 200),
type= "n", xlab = "", ylab = "", axes = FALSE)
rect(120, 140, 180, 160, border = colr, col = colr)
rect(140, 120, 160, 180, border = colr, col = colr)}
for (j in testdat){
Sys.sleep(0.3)
visualFeedback(hcol(j))
}
hcol <- heat.colors(100) # from light yellow to red
hcol <- heat.colors(100) # from light yellow to red
visualFeedback <- function(colr){
plot(c(100, 200), c(100, 200),
type= "n", xlab = "", ylab = "", axes = FALSE)
rect(120, 140, 180, 160, border = colr, col = colr)
rect(140, 120, 160, 180, border = colr, col = colr)}
for (j in testdat){
Sys.sleep(0.3)
visualFeedback(hcol[j])
}
for (j in testdat){
Sys.sleep(1)
print(visualFeedback(hcol[j]))
}
k=plot(c(100, 200), c(100, 200),
type= "n", xlab = "", ylab = "", axes = FALSE)
rect(120, 140, 180, 160, border = colr, col = colr)
barplot(testdat, ylim = c(0,100),col = colr)
barplot(testdat, ylim = c(0,100),col = hcol[1]))
barplot(testdat, ylim = c(0,100),col = hcol[1])
barplot(testdat[1], ylim = c(0,100),col = hcol[1])
barplot(testdat[2], ylim = c(0,100),col = hcol[2])
barplot(testdat[3], ylim = c(0,100),col = hcol[3])
?barplpot
?barplot
barplot(testdat, width = 0.2,
ylim = c(0,100),
col = colr)
barplot(testdat, width = 0.2,
ylim = c(0,100),
col = hcol[20])
j=20
barplot(testdat[j], width = 0.2,
ylim = c(0,100),
col = hcol[j])
barplot(testdat[j], width = 0.1,
ylim = c(0,100),
col = hcol[j])
barplot(testdat[j], space = 0.2,
ylim = c(0,100),
col = hcol[j])
barplot(testdat[j], space = 0.2,
xlim = c(0,3),
ylim = c(0,100),
col = hcol[j])
barplot(testdat[j], space = 0.2,
xlim = c(-2,3),
ylim = c(0,100),
col = hcol[j])
barplot(testdat[j], space = 0.2,
xlim = c(-1,2),
ylim = c(0,100),
col = hcol[j])
barplot(testdat[j], space = 0.2,
xlim = c(-0.5,2),
ylim = c(0,100),
col = hcol[j])
for (j in testdat){
Sys.sleep(1)
plt <- barplot(testdat[j], space = 0.2,
xlim = c(-0.5,2),
ylim = c(0,100),
col = hcol[j])
print(plt)
}
for (j in testdat){
Sys.sleep(1)
barplot(testdat[j], space = 0.2,
xlim = c(-0.5,2),
ylim = c(0,100),
col = hcol[j])
#print(plt)
}
hcol
for (j in 1:length(testdat)){
Sys.sleep(1)
barplot(testdat[j], space = 0.2,
xlim = c(-0.5,2),
ylim = c(0,100),
col = hcol[j])
#print(plt)
}
?heat.colors
barplot(1:5, col=heat.colors(5))
heat.colors(5)
testdat
testdat = round(runif(20)*100) # 20 random integers from 0 - 100
hcol <- heat.colors(100) # from light yellow to red
for (j in 1:length(testdat)){
Sys.sleep(1)
barplot(testdat[j], space = 0.2,
xlim = c(-0.5,2),
ylim = c(0,100),
col = hcol[j])
#print(plt)
}
hcol
hcol[40]
barplot(2, col = hcol[40])
for (j in 1:length(testdat)){
Sys.sleep(1)
barplot(testdat[j], space = 0.2,
xlim = c(-0.5,2),
ylim = c(0,100),
col = hcol[testdat[j]])
#print(plt)
}
library(tidyverse)
library(brainflow)
library(gsignal)
library(dbcsp) # for common spatial filters, https://journal.r-project.org/articles/RJ-2022-044/
source('./filterFuncs.r')
source('./helperFunctions.r')
# first: training on previous data
markers <- read_delim('test_run_motor.csv',
col_names = FALSE) %>%
select(val = 24) %>%
mutate(spoint = 1:n()) %>%
dplyr::filter(val > 0)  %>%
group_by(val) %>%
group_split()
markers
eegdat <- read_delim('test_run_motor.csv',
col_names = FALSE) %>%
select(c(2:9)) %>%
t()
dim(eegdat)
lf = 8
hf = 30
pollnum = 256
srate = 250
X1 = list(); X2 = list()
cspdataM = list(X1, X2)
for (con in 1:2){
lstnum = 0
for (sp in markers[[con]]$spoint){
lstnum = lstnum + 1
eegm <- t(apply(eegdat[, sp:(sp+pollnum-1)], 1, function(x) x - mean(x)))
eegf  <- bpfilt(eegm, srate, lf, hf, 6)
eegh  <- t(apply(eegf, 1, function(x) abs(hilbert(x))))
cspdataM[[con]][lstnum] = list(eegf)
}
}
bpfilt <- function(eegin, srate, lf, hf, forder){
coef <- butter(forder, c(lf, hf) / srate, 'pass')
eegout <- t(apply(eegin, 1, function(x) filtfilt(coef, x)))
}
lf = 8
hf = 30
pollnum = 256
srate = 250
X1 = list(); X2 = list()
cspdataM = list(X1, X2)
for (con in 1:2){
lstnum = 0
for (sp in markers[[con]]$spoint){
lstnum = lstnum + 1
eegm <- t(apply(eegdat[, sp:(sp+pollnum-1)], 1, function(x) x - mean(x)))
eegf  <- bpfilt(eegm, srate, lf, hf, 6)
eegh  <- t(apply(eegf, 1, function(x) abs(hilbert(x))))
cspdataM[[con]][lstnum] = list(eegf)
}
}
cspdataM
str(cspdataM)
# create list of imagined motor conditions
X1 = list(); X2 = list()
cspdataI = list(X1, X2)
for (con in 1:2){
lstnum = 0
for (sp in markers[[con]]$spoint){
lstnum = lstnum + 1
eegm <- t(apply(eegdat[, sp:(sp+pollnum-1)], 1, function(x) x - mean(x)))
eegf  <- bpfilt(eegm, srate, lf, hf, 6)
eegh  <- t(apply(eegf, 1, function(x) abs(hilbert(x))))
cspdataI[[con]][lstnum] = list(eegf)
}
}
library(dbcsp)
mydbcsp <- new('dbcsp', X1=cspdataM[[1]], X2=cspdataM[[2]], q = 8, type='dtw',
labels = c('left', 'right'))
summary(mydbcsp)
selectQ(mydbcsp, Q = c(1, 2, 3, 4, 6, 8))
selectQ(mydbcsp, Q = c(1, 2, 3, 4, 6, 8))
selectQ(mydbcsp, Q = c(1, 2, 3, 4, 6, 8))
selectQ(mydbcsp, Q = c(1, 2, 3, 4, 6, 8))
myd <- train(mydbcsp, selected_q = 3)
myd <- train(mydbcsp, selected_q = 3)
ergleft  <- predict(myd, X_test=cspdataI[[1]])$posterior[,'left']
predict(myd, X_test=cspdataI[[1]])$posterior[,'left']
predict(myd, X_test=cspdataI[[1]])
ergleft > 0.5
ergright <- predict(myd, X_test=cspdataI[[2]])$posterior[,'right']
ergright > 0.5
sum(c(ergleft, ergright)) / length(c(ergleft, ergright))
markers <- read_delim('feedbackGroup.csv',
col_names = FALSE) %>%
select(val = 24) %>%
mutate(spoint = 1:n()) %>%
dplyr::filter(val > 0)  %>%
group_by(val) %>%
group_split()
markers[[1]]
markers[[2]]
eeg <- read_delim('test_run_motor.csv',
col_names = FALSE) %>%
select(c(2:9)) %>%
t()
# channel names
cnames <- data.frame(name = c("AF1", "AF2", "AFz", "Cz",
"F1",  "Fz",  "C1",  "C2",
"Oz",  "Pz"),
easyCapNumber = numeric(10),
OpenBCI =  c("N1P", "N2P", "N3P", "N4P", "N5P",
"N6P", "N7P", "N8P",
"SRB2(REF)", "BIAS(GND)"))
# demean
demean <- function(eegin){
t(apply(eegin, 1, function(x) x - mean(x)))
}
# set arguments, zb beta, theta
lf1 <- 4
hf1 <- 7
lf2 <- 13
hf2 <- 30
pollnum <- 256 # number of samples per poll
srate   <- 250
#forder <- 4
secs    <- 30 # trial was 30 s long
pickChannels <- c("AF1", "AF2", "Cz")
# segment, demean, filter, average
chanIndex <- which(cnames$name %in% pickChannels)
# function for segmentation
segmentation <- function(onst, cindex, eegin){
lapply(onst,
function(x) eegin[cindex, x:(x+pollnum-1)])
}
# function for Welch PSD
welchpsd <- function(eegin, srate){
tmp <- apply(eegin, 1, function(x) pwelch(x, window = hanning(dim(eegin)[2]), fs = srate))
arr <- simplify2array(map(tmp, 'spec'))
pwr <- apply(arr, 1, mean)
}
segdim()
dim(seg)
seg  <- segmentation(onsets$relax, chanIndex, eeg)
markers
library(tidyverse)
library(brainflow)
library(gsignal)
## read previously recorded data
# markers
markers <- read_delim('feedbackGroup.csv',
col_names = FALSE) %>%
select(val = 24) %>%
mutate(spoint = 1:n()) %>%
dplyr::filter(val > 0)  %>%
group_by(val) %>%
group_split()
markers[[1]]
lapply(markers[[1]]$spoint, function (x) seq(x, x+sec*srate, by = pollnum)
)
lapply(markers[[1]]$spoint, function (x) seq(x, x+secs*srate, by = pollnum)
)
lf1 <- 4
hf1 <- 7
lf2 <- 13
hf2 <- 30
pollnum <- 256 # number of samples per poll
srate   <- 250
secs    <- 30 # trial was 30 s long
pickChannels <- c("AF1", "AF2", "Cz")
chanIndex <- which(cnames$name %in% pickChannels)
library(tidyverse)
library(brainflow)
library(gsignal)
## read previously recorded data
# markers
markers <- read_delim('feedbackGroup.csv',
col_names = FALSE) %>%
select(val = 24) %>%
mutate(spoint = 1:n()) %>%
dplyr::filter(val > 0)  %>%
group_by(val) %>%
group_split()
# data
eeg <- read_delim('test_run_motor.csv',
col_names = FALSE) %>%
select(c(2:9)) %>%
t()
# channel names
cnames <- data.frame(name = c("AF1", "AF2", "AFz", "Cz",
"F1",  "Fz",  "C1",  "C2",
"Oz",  "Pz"),
easyCapNumber = numeric(10),
OpenBCI =  c("N1P", "N2P", "N3P", "N4P", "N5P",
"N6P", "N7P", "N8P",
"SRB2(REF)", "BIAS(GND)"))
# set arguments, zb beta, theta
lf1 <- 4
hf1 <- 7
lf2 <- 13
hf2 <- 30
pollnum <- 256 # number of samples per poll
srate   <- 250
secs    <- 30 # trial was 30 s long
pickChannels <- c("AF1", "AF2", "Cz")
chanIndex <- which(cnames$name %in% pickChannels)
# function demean
demean <- function(eegin){
t(apply(eegin, 1, function(x) x - mean(x)))
}
# function for segmentation
segmentation <- function(onst, cindex, eegin){
lapply(onst,
function(x) eegin[cindex, x:(x+pollnum-1)])
}
# function for Welch PSD
welchpsd <- function(eegin, srate){
tmp <- apply(eegin, 1, function(x) pwelch(x, window = hanning(dim(eegin)[2]), fs = srate))
arr <- simplify2array(map(tmp, 'spec'))
pwr <- apply(arr, 1, mean)
}
lapply(markers[[1]]$spoint, function (x) seq(x, x+sec*srate, by = pollnum)
)
lapply(markers[[1]]$spoint, function (x) seq(x, x+secs*srate, by = pollnum))
simplify(lapply(markers[[1]]$spoint, function (x) seq(x, x+secs*srate, by =) pollnum))
lapply(markers[[1]]$spoint, function (x) seq(x, x+secs*srate, by = pollnum))
simplify(lapply(markers[[1]]$spoint, function (x) seq(x, x+secs*srate, by = pollnum)))
onsets = data.frame(concentrate = simplify(lapply(markers[[1]]$spoint,
function (x) seq(x, x+secs*srate, by = pollnum))),
relax = simplify(lapply(markers[[1]]$spoint,
function (x) seq(x, x+secs*srate, by = pollnum))))
onsets
onsets = data.frame(concentrate = simplify(lapply(markers[[1]]$spoint,
function (x) seq(x, x+secs*srate, by = pollnum))),
relax = simplify(lapply(markers[[2]]$spoint,
function (x) seq(x, x+secs*srate, by = pollnum))))
onsets
seg  <- segmentation(onsets$relax, chanIndex, eeg)
eegm <- lapply(seg, demean)
eegf <- lapply(eegm, function(x) welchpsd(x, srate = 250))
powerEstimateRelax <- simplify2array(eegf)
seg  <- segmentation(onsets$concentrate, chanIndex, eeg)
eegm <- lapply(seg, demean)
eegf <- lapply(eegm, function(x) welchpsd(x, srate = 250))
powerEstimateConcentrate <- simplify2array(eegf)
freqScale <- pwelch(eegm[[1]][1,],
window = hanning(dim(eegm[[1]])[2]),
fs = srate)$freq
freq1indices <- which(freqScale > lf1 & freqScale < hf1)
freq2indices <- which(freqScale > lf2 & freqScale < hf2)
plot(freqScale, apply(powerEstimateRelax, 1, mean),
type='l', col = 'blue')
lines(freqScale, apply(powerEstimateConcentrate, 1, mean),
type='l', col = 'red')
